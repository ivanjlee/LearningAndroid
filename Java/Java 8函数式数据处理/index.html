
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="shortcut icon" href="../../assets/book.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-6.1.6">
    
    
      
        <title>Java 8函数式数据处理 - 客户端知识图谱</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6910b76c.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.196e0c26.min.css">
        
          
          
          <meta name="theme-color" content="#009485">
        
      
    
    
    
      
        
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
      <link rel="stylesheet" href="../../css/app.css">
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="teal" data-md-color-accent="white">
      
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#java-8" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../.." title="客户端知识图谱" class="md-header-nav__button md-logo" aria-label="客户端知识图谱">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            客户端知识图谱
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Java 8函数式数据处理
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="客户端知识图谱" class="md-nav__button md-logo" aria-label="客户端知识图谱">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    客户端知识图谱
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." class="md-nav__link">
      主页
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" >
    <label class="md-nav__link" for="nav-2">
      Android基础
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Android基础" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon"></span>
        Android基础
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../Android/activity/" class="md-nav__link">
      【四大组件】Activity
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Android/service/" class="md-nav__link">
      【四大组件】Service
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" >
    <label class="md-nav__link" for="nav-3">
      Java基础
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Java基础" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon"></span>
        Java基础
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../%E6%B3%A8%E8%A7%A3/" class="md-nav__link">
      注解
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" >
    <label class="md-nav__link" for="nav-4">
      Kotlin基础
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Kotlin基础" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon"></span>
        Kotlin基础
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../about/" class="md-nav__link">
      None
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5" >
    <label class="md-nav__link" for="nav-5">
      跨平台技术
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="跨平台技术" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        <span class="md-nav__icon md-icon"></span>
        跨平台技术
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../about/" class="md-nav__link">
      None
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6" >
    <label class="md-nav__link" for="nav-6">
      CS理论基础
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="CS理论基础" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        <span class="md-nav__icon md-icon"></span>
        CS理论基础
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../CS/HTTP/" class="md-nav__link">
      HTTP协议
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../about/" class="md-nav__link">
      关于
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="java-8">Java 8函数式数据处理</h1>
<h1 id="1">1 流</h1>
<h2 id="11">1.1 流是什么</h2>
<p><strong>流</strong>是Java 8中新引入的概念，它允许你以声明式方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。</p>
<p>举个例子，筛选出价格大于¥50的菜品，并对这些菜品进行排序，最后返回菜品名称的集合，在Java 8之前：</p>
<pre><code class="language-Java">//第一步，筛选
List&lt;Dish&gt; tempList = new ArrayList&lt;&gt;(dishes.size());
for (Dish dish : dishes) {
    if (dish.getPriceCent() &gt; 5000) {
        tempList.add(dish);
    }
}
//第二步，排序
Collections.sort(tempList, new Comparator&lt;Dish&gt;() {
    public int compare(Dish d1, Dish d2) {
        return d1.getPriceCent() - d2.getPriceCent();
    }
});
//第三步，返回名称集合
List&lt;String&gt; result = new ArrayList&lt;&gt;(tempList.size())
for (Dish dish : tempList) {
    result.add(dish.getName());
}
</code></pre>
<p>在Java 8中，引入了流的概念之后，结合Lambda表达式：</p>
<pre><code class="language-Java">List&lt;String&gt; result = dishes.stream()
                            .filter(dish -&gt; dish.getPriceCent() &gt; 5000)
                            .sorted(comparing(Dish::getPriceCent))
                            .map(Dish::getName)
                            .collect(toList());
</code></pre>
<p>流式方法的好处：</p>
<ul>
<li>代码是以声明性方式写的，说明想要完成什么，而不是如何实现一个操作；</li>
<li>把几个基本操作链接起来，用以表达复杂的数据操作流水线，使代码清晰可读。</li>
</ul>
<p>使用Java 8的Stream API可以写出这样的代码：</p>
<ul>
<li>声明性——更简洁 ，更易读</li>
<li>可复合——更灵活</li>
<li>可并行——性能更好</li>
</ul>
<h2 id="12">1.2 流简介</h2>
<h3 id="121">1.2.1 概念和术语</h3>
<p>Java 8中的集合支持一个新的stream方法，它会返回一个流，当然也有很多其他方法，比如利用数值范围或者I/O资源也可以生成流元素。</p>
<p>定义：<strong>从支持数据处理操作的源生成得元素序列。</strong></p>
<p>关键概念：</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素序列</td>
<td>类似集合，流提供一个接口，可以访问特定元素类型的一组有序值。集合讲的是数据，流讲的是计算。</td>
</tr>
<tr>
<td>源</td>
<td>流会使用一个提供数据的源，比如集合、数组或者是I/O. 从有序集合生成流时会保留原有的序列。</td>
</tr>
<tr>
<td>数据处理操作</td>
<td>流的数据处理功能类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可以并行执行。</td>
</tr>
<tr>
<td>流水线</td>
<td>很多的流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个流水线。</td>
</tr>
<tr>
<td>内部迭代</td>
<td>和使用迭代器进行显示迭代的集合不同，流的迭代操作是在背后进行的。</td>
</tr>
</tbody>
</table>
<h3 id="122">1.2.2 外部迭代与内部迭代</h3>
<p>使用Collection接口需要用户自己去做迭代，称为<strong>外部迭代</strong>。</p>
<p>使用Stream进行的迭代是<strong>内部迭代</strong>，Stream已经帮你把迭代做了，你只需要告诉它你需要干什么就可以了。</p>
<p>外部迭代：
<img alt="外部迭代" src="../image/java8-out-iterator.PNG" /></p>
<p>内部迭代：
<img alt="" src="../image/java8-inner-iterator.PNG" /></p>
<h2 id="13">1.3 常见的流操作</h2>
<h3 id="131-collecttolist">1.3.1 collect(toList)</h3>
<p>collect(toList)方法由Stream里的值生成一个列表。of方法可以生成一个流对象。</p>
<pre><code class="language-Java">List&lt;String&gt; list = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).collect(Collectors.toList());
</code></pre>
<h3 id="132-map">1.3.2 map</h3>
<p>map操作可以将一个流中的一种值转换成另一种类型的值，生成一个新的流(一对一映射)。比如，将一个集合中的字符串全部转换成大写。</p>
<pre><code class="language-Java">List&lt;String&gt; upperCaseList = Stream.of(&quot;talk&quot;, &quot;is&quot;, &quot;cheap&quot;, &quot;,&quot;, &quot;show&quot;, &quot;me&quot;, &quot;the&quot;, &quot;code&quot;)
                .map(string -&gt; string.toUpperCase())
                .collect(Collectors.toList());

/*
    output:
    [TALK,IS,CHEAP,,,SHOW,ME,THE,CODE]
*/
</code></pre>
<p><img alt="Java 8 map" src="../image/java8-map.PNG" /></p>
<p>map操作传入的Lambda表达式必须和Function接口的签名一致。</p>
<pre><code class="language-Java">public interface Function&lt;T, R&gt; {
    R apply(T t);
}
</code></pre>
<h3 id="133-flatmap">1.3.3 flatMap</h3>
<p>flatMap方法使一个流中的每个值都换成另外一个流，然后把所有的流都连接起来成为一个流（笛卡尔乘积）。</p>
<pre><code class="language-Java">//找出两个数组中共同的元素，形成一个集合

Integer[] array1 = {1, 2, 3, 4, 5, 6, 7, 8, 9};
Integer[] array2 = {2, 3, 5, 7, 11};
List&lt;Integer[]&gt; list = Stream
                .of(array1)
                .flatMap(a1 -&gt; Stream.of(array2).filter(a1::equals).map(a2 -&gt; new Integer[]{a1, a2}))
                .collect(Collectors.toList());

/*
    output:
    [&lt;2, 2&gt;, &lt;3, 3&gt;, &lt;5, 5&gt;, &lt;7, 7&gt;]
*/
</code></pre>
<p>flatMap操作接收的Lambda表达式必须与Function接口的签名一致，传入的范型为Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt;.</p>
<h3 id="134-filter">1.3.4 filter</h3>
<p>filter用来遍历数据并选出符合特定条件的元素。比如筛选出一个字符串集合中仅含数字的字符串。</p>
<pre><code class="language-Java">List&lt;String&gt; digitList = Stream.of(&quot;a1c&quot;, &quot;123&quot;, &quot;1q2qw&quot;, &quot;0.5&quot;)
                .filter(string -&gt; TextUtils.isDigitsOnly(string))
                .collect(Collectors.toList());

/*
    output:
    [123]
*/
</code></pre>
<p><img alt="" src="../image/java8-filter.PNG" /></p>
<p>同样，filter操作传入的Lambda表达式必须和Predicate接口的签名一致。</p>
<pre><code class="language-Java">public interface Predicate&lt;T&gt; {
    boolean test(T t);
}
</code></pre>
<h3 id="135-distinct">1.3.5 distinct</h3>
<p>disdint方法会返回一个元素各异的流，简单来说，就是滤重（根据元素的hashCode和equals方法）。</p>
<pre><code class="language-Java">List&lt;Integer&gt; distinctList = Stream.of(1, 1, 2, 2, 3, 3, 3, 4)
                .distinct()
                .collect(Collectors.toList());

/*
    output:
    [1,2,3,4]
*/  
</code></pre>
<h3 id="136-limit">1.3.6 limit</h3>
<p>limit(n)会返回一个不超过给定长度的流。如果流是有序的，则最多会返回前n个元素。</p>
<pre><code class="language-Java">List&lt;Integer&gt; list = Stream.of(1, 2, 3, 4, 5, 6, 7)
                .limit(3)
                .collect(Collectors.toList());

/*
    output:
    [1,2,3]
*/
</code></pre>
<h3 id="137-skip">1.3.7 skip</h3>
<p>skip(n)，会返回扔掉前n个元素的流，如果流中元素不超过n，则会返回一个空的流。</p>
<pre><code class="language-Java">List&lt;Integer&gt; list = Stream.of(1, 2, 3, 4, 5, 6, 7)
                .skip(3)
                .collect(Collectors.toList());

/*  
    output:
    [4,5,6,7]
*/
</code></pre>
<h3 id="138-minmax">1.3.8 min和max</h3>
<p>求最小值和求最大值。比如求菜品集合中价格最低和最高的菜。</p>
<pre><code class="language-Java">List&lt;Dish&gt; dishes = ...
Dish max = dishes.stream()
    .max(Comparator.comparing(dish -&gt; dish.getPrice))
    .get();

Dish min = dishes.stream()
    .mix(Comparator.comparing(dish -&gt; dish.getPrice))
    .get();
</code></pre>
<h3 id="139-reduce">1.3.9 reduce</h3>
<p>reduce操作可以从一组值中生成一个值，实际上max和min也是reduce操作，因为太常用，所以被纳入了标准库中。举例，求和：</p>
<pre><code class="language-Java">int sum = Stream.of(1, 2, 3, 4)
    .reduce(0, (acc, element) -&gt; acc + element);
</code></pre>
<p><img alt="reduce" src="../image/java8-reduce.PNG" /></p>
<p>reduce对应的操作有3个重载的方法：</p>
<pre><code class="language-Java">//无初始值的
Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);

//等价于
boolean foundAny = false;
T result = null;
for (T element : this stream) {
    if (!foundAny) {
       foundAny = true;
        result = element;
    } else {
        result = accumulator.apply(result, element);
    }
}
return foundAny ? Optional.of(result) : Optional.empty();
</code></pre>
<pre><code class="language-Java">//带初始值的
T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);

//等价于
T result = identity;
for (T element : this stream)
    result = accumulator.apply(result, element)
return result;
</code></pre>
<pre><code class="language-Java">//参数带两个BiFuction的
&lt;U&gt; U reduce(U identity,
                BiFunction&lt;U, ? super T, U&gt; accumulator,
             BinaryOperator&lt;U&gt; combiner);

//等价于
U result = identity;
for (T element : this stream)
    result = accumulator.apply(result, element)
return result;
</code></pre>
<h3 id="1310-anymatchallmatchnonematch">1.3.10 anyMatch、allMatch和noneMatch</h3>
<p>anyMatch判断流中是否至少有一个元素能匹配给定的条件，返回一个boolean值。</p>
<pre><code class="language-Java"> boolean hasNullElements = Stream.of(&quot;Java&quot;, &quot;Python&quot;, &quot;C#&quot;, null, &quot;Ruby&quot;, &quot;Go&quot;, &quot;Object C&quot;)
                .anyMatch(Objects::isNull);
</code></pre>
<p>allMatch检查流中流中所有元素是否匹配给定的条件，返回boolean值。</p>
<p>noneMatch检查流中所以元素是否都不匹配给定的条件，返回boolean值。</p>
<h3 id="1311-findanyfindfirst">1.3.11 findAny与findFirst</h3>
<p>findAny找到流中任意一个元素(通常是第一个)，返回一个Optional对象，如果流是空的，返回一个值为空的Optional对象，如果找到的元素刚好是空值，则抛出一个NullPointerException。</p>
<pre><code class="language-Java">public final class Optional&lt;T&gt; {
    T t;
    //...
}
</code></pre>
<p>例：</p>
<pre><code class="language-Java">Optional&lt;Integer&gt; optional = Stream.of(1, 2, 3, 4, 5, 6, 7)
                .findAny();

//执行多次optional.get()始终是1
</code></pre>
<p>如果使用的是并行的流，那么findAny方法返回的值则是不确定的，比如下面的例子：</p>
<pre><code class="language-Java">List&lt;Integer&gt; array = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
Printer.println(array.parallelStream().findAny().get());
Printer.println(array.parallelStream().findAny().get());
Printer.println(array.parallelStream().findAny().get());
Printer.println(array.parallelStream().findAny().get());

/* 执行多次返回值分别是：
第1次：
5
5
5
5

Process finished with exit code 0

第2次：
4
7
2
6

Process finished with exit code 0
*/
</code></pre>
<p>findAny操作一般和filter结合起来用，用于筛选。</p>
<p>如果想始终找到第一个元素，则应该用findFirst操作，即使是并行的流，页始终能返回第一个元素。</p>
<p><em>短路求值：对于有些操作，不必处理整个流就能得到结果，就像用 || 连接起来的布尔表达式求值一样，只要提前找到一个为true的值就直接返回。流的操作中，anyMatch、findAny、findFirst都是短路操作，limit也是。</em></p>
<h2 id="14">1.4 流与集合</h2>
<h3 id="141">1.4.1 流与集合概念的差异</h3>
<p>从前面的例子中可以看到，通过Stream.of(...)方法可以得到一个流对象，看起来数据源似乎是保存在了流对象中，这和集合中保存一组数据很类似。但是，最终从流中获取一个集合，还需要调用collect(toList())方法，由此可见，流并不是集合。</p>
<p>流与集合到底有什么差异呢？举一个形象的例子，存在DVD中的电影，这就是一个集合，因为它包含了电影的全部数据，而网上在线播放的视频则是一个视频流，它只加载你当前观看的这几帧，不用等到所有的数据都加载完了才能看。</p>
<p>所以简单来讲，集合与流之间的差异就在于何时进行计算。集合是内存中的一种数据结构，它包含了数据源的所有值，集合的每个元素都需要先计算出来然后再加入到集合中。而流的元素则是按需计算，仅仅在用户需要的时候才会提取值，这是一种生产者—消费者的关系，只有消费者要求的时候才会去计算值。</p>
<h3 id="142">1.4.2 流只能遍历一次</h3>
<p>和迭代器类似，流只能遍历一次，遍历完成之后，这个流就已经被消费掉了。如果想再次遍历，需从数据源重新获取一个流（如果数据源是可重复的比如集合，这会很容易，但如果像I/O这种的话，就会很麻烦）。</p>
<p>重复消费一个流会抛出IllegalArgumentException，表示流已经被操作，或者关闭。</p>
<pre><code>List&lt;String&gt; firms = Arrays.asList(&quot;Google&quot;, &quot;AT&amp;T&quot;, &quot;Amazon&quot;, &quot;Facebook&quot;, &quot;Oracle&quot;, &quot;MicroSoft&quot;);
Stream&lt;String&gt; stream = Stream.of(firms);
stream.forEach(System.out::println);
stream.forEach(System.out::println);
</code></pre>
<h2 id="15">1.5 流的构建</h2>
<h3 id="151">1.5.1 数值流</h3>
<p>在有些流的操作中，流中的元素如果是数值，会不可避免的产生装箱和拆箱的操作，比如，对菜品的价格求和：</p>
<pre><code>List&lt;Dish&gt; dishes ...
int sumPrice = dishes.stream()
        .map(Dish::getPrice)
        .reduce(0, Integer::sum);
</code></pre>
<p>这段代码中，map操作会生成一个Stream<T>的流，因此，就需要将int类型装箱成Integer。在Java 8的Stream API中，为了避免这种拆装箱，提供了原始类型流特化，专门支持处理数值流。</p>
<h4 id="1511">1.5.1.1 原始类型流特化</h4>
<p>Java 8中引入的原始类型流特化流有3个：IntStream、LongStream和DoubleStream，分别将流的元素特化为对应的基础类型。相应的这些流中也多了一些常用的数值操作，比如sum, average, max, min等。</p>
<p>将流转化成特定的数值流常用的操作是map，对应的，map操作也有几个特定的方法，mapToInt、mapToLong、mapToDouble。比如上面对菜品价格求和的操作，就可以用IntStream来做：</p>
<pre><code class="language-Java">List&lt;Dish&gt; dishes ...
int sumPrice = dishes.stream()
        .mapToInt(Dish::getPrice)
        .sum;
</code></pre>
<p>有时候，也会有将数值流转回对象流的需求，这时候只需要将基础元素进行装箱操作就可以，使用的操作是boxed。</p>
<pre><code class="language-Java">IntStream intSream = dishes.stream()
        .mapToInt(Dish::getPrice);
Stream&lt;Integer&gt; stream = intStream.boxed();
</code></pre>
<p>上面讲findAny和findFirst操作的时候，提到了Optional对象，类似的，Optional类也对数值的基础类型进行了特化，有IntOptitonal、LongOptional和DoubleOptional三个类。</p>
<h4 id="1512">1.5.1.2 数值范围</h4>
<p>Java 8引入了两个可以用于InStream和LongStream的静态方法，range和rangeClose。区别是range不包含结束值，rangeClosed包含结束值。</p>
<pre><code class="language-Java">IntStream intStream = IntStream.range(1, 10);
        int[] array = intStream.toArray();
        Printer.print(array);
/*
    output:
    [1,2,3,4,5,6,7,8,9]
*/
</code></pre>
<pre><code class="language-Java">IntStream intStream = IntStream.rangeClosed(1, 10);
        int[] array = intStream.toArray();
        Printer.print(array);
/*
    output:
    [1,2,3,4,5,6,7,8,9,10]
</code></pre>
<h3 id="152">1.5.2 构建流的几种方式</h3>
<h4 id="1521">1.5.2.1 由值创建流</h4>
<p>使用Stream.of(T t ...)方法可以创建出一个流，Stream.empty()可以创建一个没有元素的流：</p>
<pre><code class="language-Java">Stream&lt;String&gt; stringStream = Stream.of(&quot;Apple&quot;, &quot;MicroSoft&quot;, &quot;Google&quot;, &quot;Facebook&quot;, &quot;Amazon&quot;);
Stream&lt;String&gt; emptyStream = Stream.empty();
</code></pre>
<h4 id="1522">1.5.2.2 由数组创建流</h4>
<p>Arrays.stream可以从数组创建一个流，参数是一个数组。</p>
<pre><code class="language-Java">String[] stringArray = {&quot;Apple&quot;, &quot;MicroSoft&quot;, &quot;Google&quot;, &quot;Facebook&quot;, &quot;Amazon&quot;};
int[] intArray = {0, 1, 1, 2, 3, 5, 8, 13, 21};

Stream&lt;String&gt; stringStream = Arrays.stream(stringArray);
IntStream intStream = Arrays.stream(intArray);
Stream&lt;Integer&gt; integerStream = Arrays.stream(intArray).boxed();
</code></pre>
<h4 id="1523">1.5.2.3 由集合生成流</h4>
<p>Java的Collection接口中，引入了stream()和parallelStream()两个默认方法，可以生成流。</p>
<pre><code class="language-Java">String[] stringArray = {&quot;Apple&quot;, &quot;MicroSoft&quot;, &quot;Google&quot;, &quot;Facebook&quot;, &quot;Amazon&quot;};
List&lt;String&gt; list = Arrays.asList(stringArray);
Stream&lt;String&gt; stream = list.stream();
Stream&lt;String&gt; parallelStream = list.parallelStream();
</code></pre>
<h4 id="1524">1.5.2.4 由文件生成流</h4>
<p>Java 8的NIO API中，很多操作都可以返回一个流。比如，Files.lines就会根据文件内容返回一个流。</p>
<pre><code class="language-Java">try {
            Stream&lt;String&gt; lines = Files.lines(Paths.get(&quot;.gitignore&quot;), Charset.forName(&quot;utf-8&quot;))
                    .flatMap(line -&gt; Arrays.stream(line.split(&quot; &quot;)));
            lines.forEach(word -&gt; Printer.println(word));
        } catch (IOException e) {
            e.printStackTrace();
        }

</code></pre>
<h4 id="1525">1.5.2.5 由函数生成流：创建无限流</h4>
<p>Stream API中提供了2个静态方法来从方法中生成流：Stream.iterate和Stream.generate，这2个方法都可以用来创建无限流，只要不结束，可以一直算下去。</p>
<p><strong>iterate</strong></p>
<p>iterate方法有两个重载的方法：</p>
<pre><code class="language-Java">//有结束条件的
public static&lt;T&gt; Stream&lt;T&gt; iterate(T seed, Predicate&lt;? super T&gt; hasNext, UnaryOperator&lt;T&gt; next)
</code></pre>
<p>和</p>
<pre><code class="language-Java">//没有限制，可以真正生成无限流
public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)
</code></pre>
<p>例如，生成一个斐波那契数列：</p>
<pre><code class="language-Java">Stream.iterate(new int[]{0, 1},  t -&gt; new int[] {t[1], t[0] + t[1]})
                .map(t -&gt; t[0])
                .limit(20)
                .forEach(Printer::println);
</code></pre>
<p><strong>generate</strong></p>
<p>和iterate方法类似，generate也生成一个无限流。</p>
<pre><code class="language-Java">public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;? extends T&gt; s)
</code></pre>
<p>generate方法的参数是一个Supplier，它可以是无状态的，也可以是有状态的。</p>
<p>无状态的Supplier，不会记录上一个状态，比如生成随机数，</p>
<pre><code class="language-Java">Stream.generate(Math::random)
                .limit(20)
                .forEach(Printer::println);
</code></pre>
<p>有状态的Supplier还可以是有状态的，它会记录前一个Supplier的状态（可以是值，属性等），比如还是生成一个斐波那契数列，在构建每一个元素时，都改变了supplier的属性：</p>
<pre><code class="language-Java">IntSupplier supplier = new IntSupplier() {
            private int pre = 0;
            private int cur = 1;

            @Override
            public int getAsInt() {
                int oldPre = pre;
                int oldCur = cur;
                this.pre = cur;
                this.cur = oldPre + oldCur;
                return oldPre;
            }
        };
        IntStream.generate(supplier)
                .limit(20)
                .forEach(Printer::println);
</code></pre>
<hr />
<p>Author: Ivan J. Lee
Date  : 2017-12-27 23:56</p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2020 Ivan J. Lee.
          </div>
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.fd16492e.min.js"></script>
      <script src="../../assets/javascripts/bundle.7836ba4d.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "\u590d\u5236", "clipboard.copied": "\u5df2\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\uff0c\\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: [],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.4ac00218.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
    
  </body>
</html>