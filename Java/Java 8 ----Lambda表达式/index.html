
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="shortcut icon" href="../../assets/book.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-6.1.6">
    
    
      
        <title>Java 8函数式编程–––Lambda表达式 - 客户端知识图谱</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6910b76c.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.196e0c26.min.css">
        
          
          
          <meta name="theme-color" content="#009485">
        
      
    
    
    
      
        
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
      <link rel="stylesheet" href="../../css/app.css">
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="teal" data-md-color-accent="white">
      
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#java-8lambda" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../.." title="客户端知识图谱" class="md-header-nav__button md-logo" aria-label="客户端知识图谱">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            客户端知识图谱
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Java 8函数式编程–––Lambda表达式
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="客户端知识图谱" class="md-nav__button md-logo" aria-label="客户端知识图谱">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    客户端知识图谱
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." class="md-nav__link">
      主页
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" >
    <label class="md-nav__link" for="nav-2">
      Android基础
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Android基础" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon"></span>
        Android基础
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../Android/activity/" class="md-nav__link">
      【四大组件】Activity
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Android/service/" class="md-nav__link">
      【四大组件】Service
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" >
    <label class="md-nav__link" for="nav-3">
      Java基础
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Java基础" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon"></span>
        Java基础
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../%E6%B3%A8%E8%A7%A3/" class="md-nav__link">
      注解
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" >
    <label class="md-nav__link" for="nav-4">
      Kotlin基础
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Kotlin基础" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon"></span>
        Kotlin基础
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../about/" class="md-nav__link">
      None
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5" >
    <label class="md-nav__link" for="nav-5">
      跨平台技术
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="跨平台技术" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        <span class="md-nav__icon md-icon"></span>
        跨平台技术
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../about/" class="md-nav__link">
      None
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6" >
    <label class="md-nav__link" for="nav-6">
      CS理论基础
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="CS理论基础" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        <span class="md-nav__icon md-icon"></span>
        CS理论基础
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../CS/HTTP/" class="md-nav__link">
      HTTP协议
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../about/" class="md-nav__link">
      关于
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1. 介绍
  </a>
  
    <nav class="md-nav" aria-label="1. 介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    1.1 匿名内部类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12-lambda" class="md-nav__link">
    1.2 Lambda表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13" class="md-nav__link">
    1.3 引用值而非变量
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-lambda" class="md-nav__link">
    2 Lambda表达式的应用
  </a>
  
    <nav class="md-nav" aria-label="2 Lambda表达式的应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21" class="md-nav__link">
    2.1 函数式接口
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22" class="md-nav__link">
    2.2 函数描述符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23" class="md-nav__link">
    2.3 函数式接口的使用
  </a>
  
    <nav class="md-nav" aria-label="2.3 函数式接口的使用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#231-predicate" class="md-nav__link">
    2.3.1 Predicate
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#232-consumer" class="md-nav__link">
    2.3.2 Consumer
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3 类型检查与类型推断
  </a>
  
    <nav class="md-nav" aria-label="3 类型检查与类型推断">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31" class="md-nav__link">
    3.1 类型检查
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32" class="md-nav__link">
    3.2 类型推断
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4 方法引用
  </a>
  
    <nav class="md-nav" aria-label="4 方法引用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41" class="md-nav__link">
    4.1 方法引用简介
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42" class="md-nav__link">
    4.2 构建方法引用
  </a>
  
    <nav class="md-nav" aria-label="4.2 构建方法引用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#421-3" class="md-nav__link">
    4.2.1 方法引用主要分为3类：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#412" class="md-nav__link">
    4.1.2 构造方法引用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    5 实践
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6" class="md-nav__link">
    6 小结
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="java-8lambda">Java 8函数式编程–––Lambda表达式</h1>
<h2 id="1">1. 介绍</h2>
<h3 id="11">1.1 匿名内部类</h3>
<p>设计匿名内部类的目的，是为了方便开发者将代码作为数据传递。举个栗子，在Android中，为一个按钮设置一个点击事件的监听器：</p>
<pre><code class="language-java">button.setOnClickListener(new View.OnClickListener() {
     public void onClick(View view) {
          Log.v(TAG, &quot;button is clicked!&quot;);
     }
});
</code></pre>
<h3 id="12-lambda">1.2 Lambda表达式</h3>
<p>Lambda表达式的作用和匿名内部类相似，也是为了将代码作为数据来传递，从某种意义上讲，Lambda表达式也可以理解为匿名函数，在其他的一些语言中则把称为闭包，实际上意义都差不多的。上面的例子，用Lambda表达式来改写，可以表示为：</p>
<pre><code class="language-java">button.setOnClickListener(view -&gt; Log.v(TAG, &quot;button is clicked!&quot;));
</code></pre>
<p>和使用匿名内部类传入实现了某个接口的对象不同，Lambda传入的参数是一段代码快，即匿名函数(注意这里已经不在叫方法而叫函数了)。这个匿名函数中，-&gt;将参数和Lambda表达式的主体分开，view是函数的参数，Log.v(TAG, "button is clicked!")是这个函数的具体实现。</p>
<p><img alt="lambda表达式形式" src="../image/lambda.png" /></p>
<p>lambda表达式语法：</p>
<pre><code class="language-java">(parameters) -&gt; expression
</code></pre>
<p>或者</p>
<pre><code class="language-java">(parameters) -&gt; {statemens;}
</code></pre>
<p>Lambda表达式中，参数的类型不需要显式指明，因为javac会根据程序的上下文来推断出参数的类型，这一点和kotlin很相似。</p>
<p>几个Lambda表达式的例子：</p>
<p>1、没有参数</p>
<pre><code class="language-java">Runnable runnable = () -&gt; Log.v(TAG, &quot;run&quot;);
</code></pre>
<p>2、一个参数</p>
<pre><code class="language-java">View.OnClickListener listener = view -&gt; Log.v(TAG, &quot;onClick&quot;);
</code></pre>
<p>3、一个参数包含代码块</p>
<pre><code class="language-java">Runnable runnable = () -&gt; {
     Log.v(TAG, &quot;run first step&quot;);
     Log.v(TAG, &quot;run second step&quot;);   
}
</code></pre>
<p>4、多个参数,不指定参数类型</p>
<pre><code class="language-java">Callback&lt;String&gt; callback = (arg1, arg2) -&gt; arg1 + arg2;
</code></pre>
<p>5、多个参数指定类型</p>
<pre><code class="language-java">Callback&lt;String&gt; callback = (String str1, String str2) -&gt; str1 + str2;
</code></pre>
<p>Lambda表达式的参数类型虽然可以由编译器推断出来, 但是在某些情况下, 也可能会推断不出来, 这时候就需要显式声明参数的类型了.</p>
<h3 id="13">1.3 引用值而非变量</h3>
<p>在匿名内部类中，如果需要引用外部的局部变量，则必须将这个变量设置成final类型，比如</p>
<pre><code class="language-java">final String name = getUserName();
button.setOnClickListener(new View.OnClickListener() {
     public void onClick() {
          Toast.make(context, &quot;hi, &quot; + name, Toast.LENGTH_LONG).show();
     }
});
</code></pre>
<p>为什么匿名内部类访问局部变量必须是final类型的呢？简单来说，是为了保证数值的一致性。局部变量和匿名内部类的生命周期是不一样的，如果匿名内部类直接使用局部变量的引用并修改其值，则有可能造成内外值不一致的情况，所以Java规定了匿名内部类只能引用final类型的局部变量，这样一来，值不会被真正改变，匿名内部类中，也就保证了值的一致性。</p>
<p>在Java 8中，放松了这一限制，可以引用非final类型的变量，然而，该变量在既成事实上也必须是final类型的。</p>
<p>在Lambda表达式中，实际上也只能使用final类型的局部变量，即便不加final关键字，这个变量也还是final类型的。如果试图给Lambda表达式中使用一个非final类型的变量，编译器将会报错。</p>
<pre><code class="language-java">//这段代码不能通过编译
String name = getFirstName();
name = &quot;Mr. &quot; + name;
button.setOnClickListener(view -&gt; Toast.make(context, &quot;Hi, &quot; + name, Toast.LENGTH_LONG).show());
</code></pre>
<h2 id="2-lambda">2 Lambda表达式的应用</h2>
<h3 id="21">2.1 函数式接口</h3>
<p><strong>函数接口（Functional Interface）</strong>是只有一个抽象方法的接口。例如：</p>
<pre><code class="language-java">public interface Comparator&lt;T&gt; {
    int compare(T o1, T o2);
}
</code></pre>
<p>及</p>
<pre><code class="language-java">public interface Runnable {
    void run();
}
</code></pre>
<p><em>注意：Java 8中，接口可以有默认方法，即便一个接口定义了多个默认方法，只要它的抽象方法只有一个，它仍然是一个函数式接口。</em></p>
<p>Lambda表达式与函数式接口有什么关系呢？引用书中的一句话：</p>
<blockquote>
<p>Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例（具体来说，是函数式接口一个具体实现的实例）。</p>
</blockquote>
<p>通俗一点来讲，Lambda表达式为函数式接口提供了具体的实现，从而来实现Java方法的传递（或者说是代码块传递）。当然，匿名内部类也可以实现同样的功能，只不过使用匿名内部类使用起来非常笨拙。</p>
<p>@FunctionalInterface注解用于表示一个接口被设计为了函数式接口。如果自定义的接口加了这个注解，但确不是函数式接口，IDE会在编译时报错，“Multiple non-overriding abstract methods found in interface Foo”，意思是Foo这个接口中有多个抽象方法。</p>
<p>对于函数式接口的设计，@FunctionalInterface并非是必须的，但是加上它是一个好习惯。</p>
<h3 id="22">2.2 函数描述符</h3>
<p>函数式接口中抽象方法的签名基本上也就是Lambda表达式的签名，我们把这种抽象方法叫做函数描述符。</p>
<p>比如Runnable接口可以看作是一个什么也不接收，什么也不返回的方法的签名，它的run()方法不接收任何参数，最终返回void.</p>
<p>Lambda和函数式接口的方法签名的一种记法：</p>
<pre><code class="language-java">() -&gt; void
</code></pre>
<p>这里表示的是Runnable接口所代表的方法。</p>
<p>到此为止，关于Lambda表达式，我们需要记住的是：</p>
<p><strong>1. Lambda表达式可以赋值给一个变量(函数式接口)；</strong></br>
<strong>2. Lambda表达式可以传递给一个接收函数式接口的方法。</strong></p>
<p><strong>例子：</strong>
Lambda表达式的有效使用方式：</p>
<p>(1) Lambda表达式传给一个接收函数式接口的方法</p>
<pre><code class="language-java">execute(() -&gt; {});

public void execute(Runnable r){
    r.run(); 
}
</code></pre>
<p>这里的Lambda表达式的签名是<code>() -&gt; void</code>，这是Runnable接口所代表的方法。</p>
<p>(2) Lambda表达式作为返回值</p>
<pre><code class="language-java">public Callable&lt;String&gt; fetch() {
    return () -&gt; &quot;Tricky example ;-)&quot;;
}

interface Callable&lt;T&gt; {
    T call();
}
</code></pre>
<p>fetch()方法返回一个Callable<String>对象，Callable<String>所代表的方法是<code>() -&gt; String</code>，这和例中所用的签名是一致的。</p>
<p>(3) 一种错误的用法</p>
<pre><code class="language-java">Predicate&lt;Apple&gt; p = (Apple a) -&gt; a.getWeight();

interface Predicate&lt;T&gt; {
    boolean test(T t);
}
</code></pre>
<p>例中Lambda表达式的签名是<code>(Apple) -&gt; Double</code>，Predicate<Apple>所代表的方法是<code>(Apple) -&gt; boolean</code>，不一致。</p>
<h3 id="23">2.3 函数式接口的使用</h3>
<p>上面介绍了函数式接口和函数描述符的概念，为了应用不同的Lambda表达式，就需要一套能够描述常见函数描述符的函数式接口。Java 8的java.util.function包中为我们引入了很多函数式接口。几个典型的函数式接口如下：</p>
<h4 id="231-predicate">2.3.1 Predicate</h4>
<pre><code class="language-java">@FunctionalInterface
public interface Predicate&lt;T&gt;{
    boolean test(T t);
    ...
}

</code></pre>
<p>涉及到返回值是boolean类型的表达式时，可以用Predicate<T>，例如：</p>
<pre><code class="language-java">Predicate&lt;String&gt; p = (s) -&gt; !s.isTempty();
</code></pre>
<h4 id="232-consumer">2.3.2 Consumer</h4>
<pre><code class="language-java">@FunctionalInterface
public interface Consumer&lt;T&gt;{
    void accept(T t);
    ...
}
</code></pre>
<p>需要对一个对象进行访问可以用Consumer<T>，例如：</p>
<pre><code class="language-java">//定义一个forEach方法
public void &lt;T&gt; forEach(List&lt;T&gt; list, Consumer&lt;T&gt; consumer) {
    for (Integer i : list) {
        consumer.consume(i);
    }
}

//使用
forEach(Arrays.asList(1,2,3,4,5), (Integer i) -&gt; System.out.print(i));
</code></pre>
<p>2.3.3 Function</p>
<pre><code class="language-java">@FunctionalInterface
public interface Function&lt;T, R&gt;{
    R apply(T t);
    ...
}
</code></pre>
<p>创建映射关系或者从一个对象中提取信息可以用Function<T, R>。</p>
<h2 id="3">3 类型检查与类型推断</h2>
<p>上面提到，Lambda表达式为函数式接口提供了实现，但是Lambda表达式本身并不包含实现了哪个函数式接口的任何信息，所以需要了解Lambda表达式的实际类型。</p>
<h3 id="31">3.1 类型检查</h3>
<p>Lambda表达式需要的类型称为<strong>目标类型</strong>。只要函数签名一致，Lambda表达式可以与很多函数式接口相关联。</p>
<p>一张图说明类型检查的过程：</p>
<pre><code class="language-java">List&lt;Apple&gt; heavierThan150g = filter(inventory, (Apple a) -&gt; a.getWeight() &gt; 150);
</code></pre>
<p><img alt="type check" src="../image/type_check.png" /></p>
<h3 id="32">3.2 类型推断</h3>
<p>类型推断是Java 7引入的概念，&lt;&gt;操作符可使编译器在编译时根据上下文推断出参数类型。</p>
<pre><code class="language-java">HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
</code></pre>
<p>这里，声明map时，已经明确指定了范型的类型，所以在new出HashMap对象时，编译器已经知道HashMap的具体范型。</p>
<p>Java 8中，Lambda表达式可以省略所有参数的类型。因为函数描述符可以通过目标类型来得到，所以Java编译器就可以通过上下文信息来推断出正确的参数类型，从而确定使用什么函数式接口来配合Lambda表达式。</p>
<p>当然，Lambda表达式也可以不省略参数类型，显式指定。至于这两种方式哪一种更好呢，则取决于不同的场景，有时候省略参数类型代码更易读，有的时候显式指明参数类型则比较好。</p>
<h2 id="4">4 方法引用</h2>
<h3 id="41">4.1 方法引用简介</h3>
<p>既然Lambda表达式可以与函数式接口相关联，作为函数式接口的函数描述符的引用，那么一个对象的方法有没有类似的表示方法呢？答案是有的，Java 8提供了方法引用(Method Referen)的表示方法。（在C语言或者是其他一些编程语言中，也有类似的概念，比如，C语言中的指向函数的指针，Python中把一个函数赋值给变量）</p>
<p>方法引用可以重复使用现有的方法定义，并像Lambda表达式一样传递它们。</p>
<p>方法引用通过一个::来表示，需要使用方法引用时，目标引用放在分隔符::前，方法名放在后面。</p>
<p>一些例子：</p>
<table>
<thead>
<tr>
<th>Lambda</th>
<th>方法引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>() -&gt; Thread.currentThread().dumpStack()</td>
<td>Thread.currentThread()::dumpStack</td>
</tr>
<tr>
<td>(str, i) -&gt; str.substring(i)</td>
<td>String::substring</td>
</tr>
<tr>
<td>(String s) -&gt; System.out.print(s)</td>
<td>System.out::print</td>
</tr>
</tbody>
</table>
<h3 id="42">4.2 构建方法引用</h3>
<h4 id="421-3">4.2.1 方法引用主要分为3类：</h4>
<ol>
<li>
<p>指向静态方法引用</p>
<p>例如Integer.parseInt()方法，写作Integer::parseInt</p>
</li>
<li>
<p>指向任意类型方法实例的方法引用</p>
<p>如String中的length方法，写作String::length</p>
</li>
<li>
<p>指向已有对象的实例方法的方法引用</p>
<p>比如有一个Student的实例stu，有一个方法是getName，就可以写成stu::getName</p>
</li>
</ol>
<p><strong>区别：</strong></p>
<p>静态方法引用是直接引用类的静态方法，通过 "类名::方法名"的方式引用；</p>
<p>第二种方法引用中，引用了一个对象的方法，但是这个对象本身是Lambda表达式的一个参数，不如上面的例子中，对应的Lambda表达式是(String s) -&gt; s.length()；</p>
<p>第三种中，是在Lambda表达式中调用一个已经存在的对象的方法，上面的例子改写成Lambda表达式就是() -&gt; stu.getName()，和第二种的区别就是调用的对象的方法不是Lambda的参数。</p>
<h4 id="412">4.1.2 构造方法引用</h4>
<p>对于一个现有的构造方法，可以利用它的名称和关键字new来创建一个方法引用：ClassName::new.</p>
<p>它的功能和静态方法的引用类似，比如有一个无参构造方法，适合Supplier的签名，() -&gt; Apple，那么可以这样写：</p>
<pre><code class="language-Java">Supplier&lt;Apple&gt; constuctor = Apple::new;
Apple apple = constructor.get();
</code></pre>
<p>它等价于Lambda表达式的写法：</p>
<pre><code class="language-Java">Supplier&lt;Apple&gt; constuctor = () -&gt; new Apple();
Apple apple = constructor.get();
</code></pre>
<h2 id="5">5 实践</h2>
<p>有一些菜品，存在<code>List&lt;Dish&gt; dishes</code>中，现在要将它们按照价格升序排序。</p>
<ol>
<li>
<p>在Java 8之前</p>
<p>Java 8之前，List没有sort方法，需要借助Collection类。</p>
<p><code>Java
public class DishComparator implements Comparator&lt;Dish&gt; {
    public int compare(Dish d1, Dish d2) {
        return d1.getPrice() - d2.getPrice();
    }
}
Collection.sort(list, new DishComparator());</code></p>
</li>
<li>
<p>Java 8中，使用来排序list</p>
<p>Java 8之前，List没有sort方法，需要借助Collection类。</p>
<p><code>Java
public class DishComparator implements Comparator&lt;Dish&gt; {
    public int compare(Dish d1, Dish d2) {
        return d1.getPrice() - d2.getPrice();
    }
}
list.sort(new DishComparator());</code></p>
</li>
<li>
<p>使用匿名内部类</p>
<p><code>Java
list.sort(new Comparator&lt;Dish&gt; {
    public int compare(Dish d1, Dish d2) {
        return d1.getPrice() - d2.getPrice();
    }
});</code></p>
</li>
<li>
<p>使用Lambda表达式</p>
<p><code>Java
list.sort((Dish d1, Dish d2) -&gt; d1.getPrice() - d2.getPrice());</code></p>
</li>
<li>
<p>使用方法引用</p>
<p><code>Java
list.sort(Comparator.comparating(Dish::getPrice))</code></p>
</li>
</ol>
<h2 id="6">6 小结</h2>
<ul>
<li><strong>Lambda表达式</strong>可以理解为一种匿名函数：没有名称，但有参数列表、函数主体、返回值；</li>
<li>Lambda表达式可以让你更简洁的传递代码；</li>
<li><strong>函数式接口</strong>就是仅仅声明了一个抽象方法的接口；</li>
<li>只有在接收函数式接口的地方才可以使用Lambda表达式；</li>
<li>Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的的一个实例；</li>
<li>Java 8自带一些常用的函数式接口，在java.util.function包里，包括Predicate<T>、Function<T,R>、Supplier<T>、Consumer<T>等；</li>
<li>Lambda表达式所需要的代表的类型成为目标类型；</li>
<li>方法引用让你重复使用现有的方法实现并直接传递它们；</li>
<li>Comparator、Predicate、和Function等函数式接口有几个可以结合Lambda表达式的默认方法。</li>
</ul>
<p>--</p>
<p>作者：Ivan J. Lee</br>
时间：2017-11-28 00:40</p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2020 Ivan J. Lee.
          </div>
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.fd16492e.min.js"></script>
      <script src="../../assets/javascripts/bundle.7836ba4d.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "\u590d\u5236", "clipboard.copied": "\u5df2\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\uff0c\\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: [],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.4ac00218.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
    
  </body>
</html>